from profile import *
import cqueue
import motor
import encoder
import pyb
import utime
import controller

# This code creates motor driver and encoder objects (same as always)
driver = motor.MotorDriver()
driver.motorA.enable()
enc = encoder.Encoder(4, pyb.Pin.cpu.B6, pyb.Pin.cpu.B7)
enc.zero()

# Collects all the parameters of the sine sweep, either from user input
# or from a jupyter notebook
while True:
    try:
        omega_ss = float(input("Steady State Velocity [rad/s]: "))
        t_ss = float(input("Steady State Velocity Time [s]: "))
        t_acc = float(input("Acceleration/Deceleration Time [s]: "))
        t_stop = float(input("Stopped Time [s]: "))
        kp = float(input("Proportional Gain [%/rad/s]: "))
        ki = float(input("Integral Gain [%/rad]: "))
    except ValueError:
        print("Invalid input")
        continue
    else:
        break

period_us = 2000
delta_t = period_us / 1e6

con = controller.PIController(kp, ki, 100, delta_t, 0)

# Queues to store data (faster than arrays, must specify size)
N = trapz_profile_length(omega_ss, t_acc, t_ss, t_stop, delta_t)
t_queue = cqueue.FloatQueue(N)
omega_sp_queue = cqueue.FloatQueue(N)
omega_meas_queue = cqueue.FloatQueue(N)

# Used to keep the main loop running at the right period
next_time_us = utime.ticks_us() + period_us

sweep_profile = trapz_profile_gen(omega_ss, t_acc, t_ss, t_stop, delta_t)
# Main loop
for t, omega_sp in sweep_profile:
    # Read the velocity of the encoder, in radians per second
    omega_meas = enc.get_velocity_rad()
    
    # WRITE YOUR CODE HERE to set the setpoint to omega_sp, generated by profile
    con.set_setpoint(omega_sp)

    # WRITE YOUR CODE HERE to run the controller using the measured velocity
    output = con.run(omega_meas)
    
    # WRITE YOUR CODE HERE to set the percent voltage on the motor
    driver.motorA.set_voltage_percent(output)
    
    # WRITE YOUR CODE HERE to put the data in the queues. t_queue is an example
    t_queue.put(t)

    # Loop timing, DO NOT write any code past this point in the for loop
    # Wait until it is time to run the next point. pass means do nothing
    while utime.ticks_diff(utime.ticks_us(), next_time_us) < 0:
        pass
    # Calculate the next time to run the loop
    next_time_us = utime.ticks_add(next_time_us, period_us)

# Shut off the motor
driver.motorA.disable()

# Print the data gathered
while t_queue.any():
    print(t_queue.get(), omega_sp_queue.get(), omega_meas_queue.get(), sep=',')
# Marker for data end, detected by Jupyter Notebook
print('END')
